# -*- coding: utf-8 -*-
""" Bybit Spot Bot ‚Äî v3 + NetPnL‚Äë—Ç—Ä–µ–π–ª–∏–Ω–≥ + Unified Averaging + State Comparison
–°–æ—Ö—Ä–∞–Ω—è–µ—Ç –≤–µ—Å—å –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª, –¥–æ–±–∞–≤–ª—è–µ—Ç —Ñ–∏–∫—Å–∞—Ü–∏—é –ø—Ä–∏–±—ã–ª–∏ ‚â• $1.5,
—Å trailing‚Äëexit –ø—Ä–∏ —Å–Ω–∏–∂–µ–Ω–∏–∏ netPnL –Ω–∞ ‚â• $0.6 –æ—Ç –ø–∏–∫–æ–≤–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è, —É—Å—Ä–µ–¥–Ω–µ–Ω–∏–µ ‚â§‚ÄØ2 –ø–æ–∫—É–ø–æ–∫,
–æ–±—ä–µ–¥–∏–Ω–µ–Ω–æ –≤ –æ–¥–Ω—É –ø–æ–∑–∏—Ü–∏—é, –∏ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –¥–æ/–ø–æ—Å–ª–µ —É—Å—Ä–µ–¥–Ω–µ–Ω–∏—è.
"""

import os, time, math, logging, datetime, json, traceback
import pandas as pd
import requests
from dotenv import load_dotenv
from pybit.unified_trading import HTTP
from ta.trend import EMAIndicator, MACD
from ta.momentum import RSIIndicator
from ta.volatility import AverageTrueRange

# ============ ENV ============
load_dotenv()
API_KEY    = os.getenv("BYBIT_API_KEY") or ""
API_SECRET = os.getenv("BYBIT_API_SECRET") or ""
TG_TOKEN   = os.getenv("TG_TOKEN") or ""
CHAT_ID    = os.getenv("CHAT_ID") or ""
REDIS_URL  = os.getenv("REDIS_URL") or ""

try:
    import redis
    rds = redis.from_url(REDIS_URL, decode_responses=True) if REDIS_URL else None
except Exception:
    rds = None

# ============ CONFIG ============
SYMBOLS = ["TONUSDT", "DOGEUSDT", "XRPUSDT", "SOLUSDT", "AVAXUSDT", "ADAUSDT", "BTCUSDT"]
TAKER_FEE = 0.0018
BASE_MAX_TRADE_USDT = 35.0
MAX_TRADE_OVERRIDES = {"TONUSDT": 70.0, "AVAXUSDT": 70.0, "ADAUSDT": 60.0}
def max_trade_for(sym: str) -> float:
    return float(MAX_TRADE_OVERRIDES.get(sym, BASE_MAX_TRADE_USDT))

RESERVE_BALANCE = 1.0
TRAIL_MULTIPLIER = 1.5
MAX_DRAWDOWN = 0.10
MAX_AVERAGES = 2
STOP_LOSS_PCT = 0.03
MIN_PROFIT_PCT = 0.005
MIN_ABS_PNL = 0.0
MIN_NET_PROFIT = 1.50
MIN_NET_ABS_USD = 1.50
SLIP_BUFFER = 0.006
PROFIT_ONLY = False

USE_VOLUME_FILTER = True
VOL_MA_WINDOW = 20
VOL_FACTOR_MIN = 0.4
MIN_CANDLE_NOTIONAL = 15.0

USE_ORDERBOOK_GUARD = True
OB_LIMIT_DEPTH = 25
MAX_SPREAD_BP = 25
MAX_IMPACT_BP = 35

LIQUIDITY_RECOVERY = True
LIQ_RECOVERY_USDT_MIN = 20.0
LIQ_RECOVERY_USDT_TARGET = 60.0

BTC_SYMBOL = "BTCUSDT"
BTC_MAX_SELL_FRACTION_TRADE = 0.18
BTC_MIN_KEEP_USD = 3000.0

INTERVAL = "1"
STATE_FILE = "state.json"
LOOP_SLEEP = 60
DAILY_REPORT_HOUR = 22
DAILY_REPORT_MINUTE = 30
WALLET_CACHE_TTL = 5.0
REQUEST_BACKOFF = 2.5
REQUEST_BACKOFF_MAX = 30.0
TG_ERR_COOLDOWN = 90.0
TRAIL_PNL_TRIGGER = 1.5
TRAIL_PNL_GAP = 0.6

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s | %(message)s",
    handlers=[logging.FileHandler("bot.log", encoding="utf-8"), logging.StreamHandler()]
)

def send_tg(msg: str):
    if not TG_TOKEN or not CHAT_ID: return
    try:
        requests.post(f"https://api.telegram.org/bot{TG_TOKEN}/sendMessage", data={"chat_id": CHAT_ID, "text": msg})
    except Exception as e:
        logging.error(f"TG send failed: {e}")

def tg_event(msg: str): send_tg(msg)

session = HTTP(api_key=API_KEY, api_secret=API_SECRET, recv_window=15000)
STATE = {}
LIMITS = {}
LAST_REPORT_DATE = None
_last_err_ts = 0.0
_wallet_cache = {"ts": 0.0, "coins": None}

def _state_key(): return "bybit_spot_state_v3"
def _save_state():
    s = json.dumps(STATE, ensure_ascii=False)
    try:
        if rds: rds.set(_state_key(), s)
    except Exception: pass
    try:
        with open(STATE_FILE, "w", encoding="utf-8") as f: f.write(s)
    except Exception as e:
        logging.error(f"save_state error: {e}")

def _load_state():
    global STATE
    if rds:
        try:
            s = rds.get(_state_key())
            if s:
                STATE = json.loads(s)
                return "REDIS"
        except Exception: pass
    try:
        with open(STATE_FILE, "r", encoding="utf-8") as f:
            STATE = json.load(f)
            return "FILE"
    except Exception:
        STATE = {}
        return "FRESH"

def init_state():
    src = _load_state()
    logging.info(f"üöÄ –ë–æ—Ç —Å—Ç–∞—Ä—Ç—É–µ—Ç. –°–æ—Å—Ç–æ—è–Ω–∏–µ: {src}")
    tg_event(f"üöÄ –ë–æ—Ç —Å—Ç–∞—Ä—Ç—É–µ—Ç. –°–æ—Å—Ç–æ—è–Ω–∏–µ: {src}")
    for s in SYMBOLS:
        STATE.setdefault(s, {"positions": [], "pnl": 0.0, "count": 0, "avg_count": 0, "last_sell_price": 0.0, "max_drawdown": 0.0})
    _save_state()

def _attempt_buy(sym: str, qty_base: float) -> bool:
    lm = LIMITS[sym]
    qty = round_step(qty_base, lm["qty_step"])
    tries = 4
    while tries > 0 and qty >= lm["min_qty"]:
        try:
            _safe_call(session.place_order,
                category="spot", symbol=sym,
                side="Buy", orderType="Market",
                timeInForce="IOC", marketUnit="baseCoin",
                qty=str(qty))
            return True
        except Exception as e:
            msg = str(e)
            if "170131" in msg or "Insufficient balance" in msg:
                logging.info(f"[{sym}] 170131 on BUY qty={qty}. Shrink & retry")
                shrink = max(lm["qty_step"], qty * 0.005)
                qty = round_step(max(lm["min_qty"], qty - shrink), lm["qty_step"])
                tries -= 1
                time.sleep(0.3)
                continue
            if "x-bapi-limit-reset-timestamp" in msg:
                time.sleep(0.8)
                continue
            tg_event(f"[{sym}] ‚ùå –û—à–∏–±–∫–∞ –ø–æ–∫—É–ø–∫–∏: {e}")
            return False
    tg_event(f"[{sym}] ‚ùå –ü–æ–∫—É–ø–∫–∞ –Ω–µ —É–¥–∞–ª–∞—Å—å –ø–æ—Å–ª–µ {4 - tries} –ø–æ–ø—ã—Ç–æ–∫ ‚Äî –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ–∫ —Å—Ä–µ–¥—Å—Ç–≤ –∏–ª–∏ –ª–∏–º–∏—Ç—ã.")
    return False
